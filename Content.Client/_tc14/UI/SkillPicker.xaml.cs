using System.Linq;
using Content.Client.Message;
using Content.Shared._tc14.CCVar;
using Content.Shared._tc14.Skills.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Prototypes;

namespace Content.Client._tc14.UI;

//TODO saving and stuff
[GenerateTypedNameReferences]
public sealed partial class SkillPicker : BoxContainer
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    [Dependency] private readonly IConfigurationManager _configurationManager = default!;

    private readonly int _passionPoints;
    private readonly int _maxPointsPerSkill;
    private readonly IEnumerable<SkillPrototype> _skills;
    private Dictionary<ProtoId<SkillPrototype>, SpinBox> _spinBoxes = new();
    public Action<Dictionary<ProtoId<SkillPrototype>, int>>? OnPassionsChanged;

    public SkillPicker(IReadOnlyDictionary<ProtoId<SkillPrototype>, int> passions)
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _passionPoints = _configurationManager.GetCVar(CCVars.MaxPassionPoints);
        _maxPointsPerSkill = _configurationManager.GetCVar(CCVars.MaxPointsPerSkill);
        _skills = _prototypeManager.EnumeratePrototypes<SkillPrototype>();
        _skills = _skills.OrderByDescending(s => s.Priority);
        BuildEntries(passions);
        UpdatePassions();
    }

    private void BuildEntries(IReadOnlyDictionary<ProtoId<SkillPrototype>, int> passions)
    {
        foreach (var skill in _skills)
        {
            var skillNameLabel = new RichTextLabel
            {
                Margin = new Thickness(0, 0, 10, 0),
            };
            skillNameLabel.SetMarkup(Loc.GetString(skill.Name));
            SkillPassionContainer.AddChild(skillNameLabel);

            var passionSpinBox = new SpinBox
            {
                HorizontalAlignment = HAlignment.Center,
                HorizontalExpand = true,
                Value = 0,
                IsValid = i => i >= 0 && i <= _maxPointsPerSkill,
            };
            if (passions.TryGetValue(skill.ID, out var value))
                passionSpinBox.Value = value;
            passionSpinBox.InitDefaultButtons();
            passionSpinBox.ValueChanged += args => UpdatePassions(args, skill);
            SkillPassionContainer.AddChild(passionSpinBox);
            _spinBoxes.Add(skill.ID, passionSpinBox);
        }
    }

    private void UpdatePassions(ValueChangedEventArgs? args = null, SkillPrototype? skill = null)
    {
        var pointsSum = _spinBoxes.Values.Sum(spinBox => spinBox.Value);
        SkillPassionPointsLabel.Text = Loc.GetString("skills-passionmenu-label",
            ("points", pointsSum),
            ("maxPoints", _passionPoints));
        if (pointsSum < _passionPoints)
        {
            SkillPassionPointsLabel.Modulate = Color.Yellow;
        }
        else if (pointsSum == _passionPoints)
        {
            SkillPassionPointsLabel.Modulate = Color.White;
        }
        else
        {
            SkillPassionPointsLabel.Modulate = Color.Red;
            //this is not good in terms of UX - the + buttons are still enabled. However, SpinBox doesn't allow a better solution - yet.
            if (args is not null && skill is not null)
            {
                _spinBoxes[skill].Value -= 1;
                UpdatePassions();
            }
        }
        var dict = _spinBoxes.ToDictionary(pair => pair.Key, pair => pair.Value.Value);
        OnPassionsChanged?.Invoke(dict);
    }
}
